<html>
<head>
    <title>Lerping</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="../libs/three.js"></script>
<script src="../libs/orbitControls.js"></script>
<div id="container">
    <canvas id="canvas"></canvas>
</div>
<script>

  'use strict';

  var camera, scene, renderer, cameraControls, light;
  var clock = new THREE.Clock();
  var mesh, material;

  var cubesCount,
    meshes = [],
    materials = [],
    xgrid = 18,
    ygrid = 6;

  var nextShape;
  var shapes = {random: [], cube: [], helix: [], conic: [], cylinder: [], sphere: []};

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();
  var intersected;


  scene = new THREE.Scene();

  function init() {
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x000000, 1.0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = -10;
    camera.position.y = 0;
    camera.position.z = 500;

    cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
    cameraControls.addEventListener('change', render); // remove when using animation loop
    cameraControls.enableZoom = false;

    fillScene();

    window.addEventListener('resize', onWindowResize, false);
    renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
  }


  function fillScene() {
    scene = new THREE.Scene();

    addLight();
    createCubes();
    initShapesPositions();
    nextShape = 'cube';

    setNewShapePosition();

    endMeshesTransition = true;
  }

  function addLight () {
    light = new THREE.AmbientLight(0x606060);
    scene.add(light);

    light = new THREE.PointLight(0xffffff, 1, 700);
    light.position.set(0, 20, 120);
    scene.add(light);
  }


  function createCubes() {
    var i, j, ux, uy, ox, oy,
      geometry,
      xsize, ysize;

    ux = 1 / xgrid;
    uy = 1 / ygrid;

    xsize = 240 / xgrid;
    ysize = 120 / ygrid;

    var parameters = {color: 0xffffff};
    cubesCount = 0;

    for (i = 0; i < xgrid; i += 2) {
      for (j = 0; j < ygrid; j += 2) {

        ox = i;
        oy = j;
        geometry = new THREE.CubeGeometry(xsize, ysize, xsize);
        changeUVs(geometry, ux, uy, ox, oy);

        materials[cubesCount] = new THREE.MeshPhongMaterial(parameters);

        material = materials[cubesCount];

        mesh = new THREE.Mesh(geometry, material);

        mesh.position.x = ( i - xgrid / 2 ) * xsize;
        mesh.position.y = ( j - ygrid / 2 ) * ysize;
        mesh.position.z = 0;
        mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
        scene.add(mesh);

        mesh.dx = 0.001 * ( 0.5 - Math.random() );
        mesh.dy = 0.001 * ( 0.5 - Math.random() );
        mesh.position.floor();
        meshes[cubesCount] = mesh;
        cubesCount += 1;
      }
    }
  }


  function changeUVs(geometry, unitX, unitY, offsetX, offsetY) {
    var faceVertexUvs = geometry.faceVertexUvs[0];

    for (var i = 0; i < faceVertexUvs.length; i++) {
      var uvs = faceVertexUvs[i];

      for (var j = 0; j < uvs.length; j++) {
        var uv = uvs[j];

        uv.x = ( uv.x + offsetX ) * unitX;
        uv.y = ( uv.y + offsetY ) * unitY;
      }
    }
  }


  function initShapesPositions() {
    var object, position;
    var phi, theta, axisY;
    var cylindrical, spherical;
    var i;

    //random
    for (i = 0; i < cubesCount; i++) {
      position = new THREE.Vector3(
        Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100
      );
      position.floor();

      shapes.random.push(position);
    }

    //cube
    var stepSize = 0.5;

    for (var x = 0; x <= 1.0; x += stepSize) {
      for (var y = 0; y <= 1.0; y += stepSize) {
        for (var z = 0; z <= 1.0; z += stepSize) {
          position = new THREE.Vector3(x * 60 - 40, y * 60 - 50, z * 60 - 50);
          position.floor();

          shapes.cube.push(position);
        }
      }
    }

    //helix
    cylindrical = new THREE.Cylindrical();

    for (i = 0; i < cubesCount; i++) {
      theta = i * 0.475 + Math.PI;
      axisY = -( i * 4 ) + 30;

      object = new THREE.Object3D();
      cylindrical.set(70, theta, axisY);
      object.position.setFromCylindrical(cylindrical);

      position = new THREE.Vector3(object.position.x, object.position.y, object.position.z);
      position.floor();

      shapes.helix.push(position);
    }

    //conic
    cylindrical = new THREE.Cylindrical();

    for (i = 0; i < cubesCount; i++) {
      theta = i * 0.475 + Math.PI;
      axisY = -( i * 5 ) + 30;

      object = new THREE.Object3D();
      cylindrical.set(30 + 5 * i, theta, axisY);
      object.position.setFromCylindrical(cylindrical);

      position = new THREE.Vector3(object.position.x, object.position.y, object.position.z);
      position.floor();

      shapes.conic.push(position);
    }

    //cylinder
    cylindrical = new THREE.Cylindrical();

    for (i = 0; i < cubesCount; i++) {
      theta = i * 0.698 + Math.PI;
      axisY = -( Math.floor(i / 9) % 9 ) * 40 + 20;

      object = new THREE.Object3D();
      cylindrical.set(120, theta, axisY);
      object.position.setFromCylindrical(cylindrical);

      position = new THREE.Vector3(object.position.x, object.position.y, object.position.z);
      position.floor();

      shapes.cylinder.push(position);
    }

    //sphere
    spherical = new THREE.Spherical();

    for (i = 0; i < cubesCount; i++) {
      phi = Math.acos(-1 + ( 2 * i ) / cubesCount);
      theta = Math.sqrt(cubesCount * Math.PI) * phi;

      object = new THREE.Object3D();
      spherical.set(80, phi, theta);
      object.position.setFromSpherical(spherical);

      position = new THREE.Vector3(object.position.x, object.position.y, object.position.z);
      position.floor();

      shapes.sphere.push(position);
    }
  }


  function setNewShapePosition() {
    var positions = [];

    switch (nextShape) {
      case 'random':
        positions = shapes.random;
        nextShape = 'cube';
        break;

      case 'cube':
        positions = shapes.cube;
        nextShape = 'sphere';
        break;

      case 'sphere':
        positions = shapes.sphere;
        nextShape = 'helix';
        break;

      case 'helix':
        positions = shapes.helix;
        nextShape = 'conic';
        break;

      case 'conic':
        positions = shapes.conic;
        nextShape = 'cylinder';
        break;

      case 'cylinder':
        positions = shapes.cylinder;
        nextShape = 'random';
        break;
    }

    for (var i = 0; i < cubesCount; i++) {
      meshes[i].newPosition = positions[i];
    }
  }


  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }


  function animate() {
    var delta = clock.getDelta();
    cameraControls.update(delta);

    window.requestAnimationFrame(animate);
    render();
  }


  var timer, alpha, currentX, currentY, currentZ, delta, endMeshesTransition;

  timer = 0;
  alpha = 0;

  function render() {
    delta = clock.getDelta();

    if (timer % 500 === 0 && timer !== 0) {
      alpha = 0;
      endMeshesTransition = false;
    }

    if (!endMeshesTransition) {
      endMeshesTransition = true;

      for (var i = 0; i < cubesCount; i++) {
        mesh = meshes[i];

        currentX = Math.abs(mesh.newPosition.x - mesh.position.x);
        currentY = Math.abs(mesh.newPosition.y - mesh.position.y);
        currentZ = Math.abs(mesh.newPosition.z - mesh.position.z);

        if (currentX >= 1 || currentY >= 1 || currentZ >= 1) {
          alpha += delta / 20;
          mesh.position.lerp(mesh.newPosition, alpha);

          endMeshesTransition = false;
        }
      }

      if (endMeshesTransition) {
        setNewShapePosition();
      }
    }

    timer++;
    renderer.render(scene, camera);
  }


  function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;


    raycaster.setFromCamera(mouse, camera);
    var intersections;

    intersections = raycaster.intersectObjects(meshes);

    if (intersections.length > 0) {
      if (intersected != intersections[0].object) {
        intersected = intersections[0].object;
        intersected.material.color.setHex(Math.random() * 0xffffff);

      }

      document.body.style.cursor = 'pointer';
    } else if (intersected) {

      intersected = null;
      document.body.style.cursor = 'auto';
    }
  }


  function addToDOM() {
    var container = document.getElementById('container');
    var canvas = container.getElementsByTagName('canvas');

    if (canvas.length > 0) {
      container.removeChild(canvas[0]);
    }
    container.appendChild(renderer.domElement);
  }

  try {
    init();
    addToDOM();
    animate();
  } catch (e) {
    var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
    $('#container').append(errorReport + e);
  }
</script>
</body>
</html>
