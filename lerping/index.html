<html>
<head>
    <title>Lerping</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="../libs/three.js"></script>
<script src="../libs/orbitControls.js"></script>
<div id="container">
    <canvas id="canvas"></canvas>
</div>
<script>

  'use strict';

  var camera, scene, renderer, cameraControls;
  var clock = new THREE.Clock();
  var mesh, material;

  var cubesCount,
    meshes = [],
    materials = [],
    xgrid = 18,
    ygrid = 6;

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();
  var intersected;


  scene = new THREE.Scene();

  function init() {
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x000000, 1.0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = -10;
    camera.position.y = 0;
    camera.position.z = 500;

    cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
    cameraControls.addEventListener('change', render); // remove when using animation loop
    cameraControls.enableZoom = false;

    fillScene();

    window.addEventListener('resize', onWindowResize, false);
    renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
  }


  function fillScene() {
    scene = new THREE.Scene();

    createCubes();
  }

  function createCubes() {
    var i, j, ux, uy, ox, oy,
      geometry,
      xsize, ysize;

    ux = 1 / xgrid;
    uy = 1 / ygrid;

    xsize = 240 / xgrid;
    ysize = 120 / ygrid;

    var parameters = {color: 0xffffff, transparent: true, opacity: 0.8};
    cubesCount = 0;

    for (i = 0; i < xgrid; i += 2) {
      for (j = 0; j < ygrid; j += 2) {

        ox = i;
        oy = j;
        geometry = new THREE.CubeGeometry(xsize, ysize, xsize);
        changeUVs(geometry, ux, uy, ox, oy);

        materials[cubesCount] = new THREE.MeshBasicMaterial(parameters);
        materials[cubesCount].side = THREE.DoubleSide;

        material = materials[cubesCount];

        mesh = new THREE.Mesh(geometry, material);

        mesh.position.x = ( i - xgrid / 2 ) * xsize;
        mesh.position.y = ( j - ygrid / 2 ) * ysize;
        mesh.position.z = 0;
        mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
        scene.add(mesh);

        mesh.dx = 0.01 * (0.5 - Math.random());
        mesh.dy = 0.01 * (0.5 - Math.random());
        mesh.newPosition = new THREE.Vector3(
          Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100
        );

        mesh.endTransition = true;
        mesh.newPosition.floor();
        mesh.position.floor();
        meshes[cubesCount] = mesh;
        cubesCount += 1;
      }
    }
  }


  function changeUVs(geometry, unitX, unitY, offsetX, offsetY) {
    var faceVertexUvs = geometry.faceVertexUvs[0];

    for (var i = 0; i < faceVertexUvs.length; i++) {
      var uvs = faceVertexUvs[i];

      for (var j = 0; j < uvs.length; j++) {
        var uv = uvs[j];

        uv.x = ( uv.x + offsetX ) * unitX;
        uv.y = ( uv.y + offsetY ) * unitY;
      }
    }
  }


  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }


  function animate() {
    var delta = clock.getDelta();
    cameraControls.update(delta);

    window.requestAnimationFrame(animate);
    render();
  }


  var timer = 0;
  var alphaTime = 0;
  var currentX, currentY, currentZ;
  var delta;


  var positions;
  positions = [];

  var stepSize = 0.5;
  for ( var alpha = 0; alpha <= 1.0; alpha += stepSize ) {
    for ( var beta = 0; beta <= 1.0; beta += stepSize ) {
      for ( var gamma = 0; gamma <= 1.0; gamma += stepSize ) {
        positions.push(new THREE.Vector3(
          alpha * 60 - 50, beta * 60 - 50,gamma * 60 - 50
        ));
      }
    }
  }


  function render() {
    delta = clock.getDelta();
    for (var i = 0; i < cubesCount; i++) {
      mesh = meshes[i];

      mesh.rotation.x += mesh.dx;
      mesh.rotation.y += mesh.dy;

      if (timer % 500 === 0 && timer !== 0) {
        alphaTime = 0;
        mesh.endTransition = false;
      }

      if (!mesh.endTransition) {
        currentX = Math.abs(mesh.newPosition.x - mesh.position.x);
        currentY = Math.abs(mesh.newPosition.y - mesh.position.y);
        currentZ = Math.abs(mesh.newPosition.z - mesh.position.z);

        if (currentX >= 1 || currentY >= 1 || currentZ >= 1) {
          alphaTime += delta / 20;
          mesh.position.lerp(mesh.newPosition, alphaTime);
        } else {
          mesh.endTransition = true;

          mesh.newPosition = positions[i];
        }
      }
    }

    timer++;
    renderer.render(scene, camera);
  }


  function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;


    raycaster.setFromCamera(mouse, camera);
    var intersections;

    intersections = raycaster.intersectObjects(meshes);

    if (intersections.length > 0) {
      if (intersected != intersections[0].object) {
        intersected = intersections[0].object;
        intersected.material.color.setHex(Math.random() * 0xffffff);

      }

      document.body.style.cursor = 'pointer';
    } else if (intersected) {

      intersected = null;
      document.body.style.cursor = 'auto';
    }

    // update tracker
  }


  function addToDOM() {
    var container = document.getElementById('container');
    var canvas = container.getElementsByTagName('canvas');

    if (canvas.length > 0) {
      container.removeChild(canvas[0]);
    }
    container.appendChild(renderer.domElement);
  }

  try {
    init();
    addToDOM();
    animate();
  } catch (e) {
    var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
    $('#container').append(errorReport + e);
  }
</script>
</body>
</html>
